\section{The \OPT{} Programming Model}
\label{sec:language}

\OPT{} uses a simple programming model, modeled after the pipeline abstractions of systems like OpenGL and CUDA. In \OPT, the programmer writes energy functions in a simple expression language (\secref{expression_language}), then uses a simple C API (\secref{runtime_api}) to configure a logical optimization pipeline to minimize this objective over an image with a given solver strategy, bind memory for inputs and unknowns, and iterate the solver on the data.
          
\subsection{Energy Function Expression Language} % (fold)
\label{sec:expression_language}

In \OPT, an energy function is declared as a function of some parameters (like uniform values in a shading language), input and unknown images, and problem dimensions. Parameters and images each have a type (\code{float}, \code{float4}, etc.), and images also have dimensions (specified in terms of the declared problem dimensions).
The energy function is described using a simple expression language.
Expressions include:

\begin{itemize}
  \item basic arithmetic, mathematical, and logical operations
  \item numerical constants
  \item references to parameters
  \item accesses to images, including the unknown image, at constant offsets relative to the current pixel (\emph{stencil references})
  \item \JRK{Index(int,int,int), Bounds(int, int, int, int)}
\end{itemize}
%
\JRK{The full expression language is described in \TODO{make, reference expression language BNF figure}}
The objective is specified in a dedicated \code{sumsquared} operator, which explicitly captures the sum of squares form required of the objective, and helps the compiler track and retain this structure through any transformations.

The \OPT code for a Laplacian image smoothing objective is shown in \figref{laplacian_energy_code}. The objective is given as the sum of two squared sub-terms: the Laplacian cost, and the reconstruction cost.
The reconstruction cost is simply the difference between the unknown \code{X} and the input \code{A} at the current pixel \code{(0,0)}.
The Laplacian cost.
The relative influence of each term is controlled by the constant coefficients \code{w\_fit} and \code{w\_reg}.
\JRK{Why is there a ``zero'' param?}

Given an energy function, the system is responsible for computing any derivative terms required the solver method.
However, in case automatic differentiation ever produces poor results or fails to capture some special domain knowledge, there is also an escape hatch: the programmer can provide the required derivative terms manually, using the same expression language, and skip automatic differentiation.

% subsection expression_language (end)

\subsection{Runtime API} % (fold)
\label{sec:runtime_api}

Given an energy function, a programmer sets up and solves an optimization problem using \OPT's C runtime API (\figref{runtime_api}).
  % optimizerState = Opt_NewState();
The programmer first constructs a new \code{OptimizerContext}.
%with \code{Opt_NewState()}.
  % 1. Define: loads program and chooses method - (does type checking, etc.)
  % Problem * prob = Opt_ProblemDefine(optimizerState,
  %                                    example.terraCodeFilename.c_str(),
  %                                    method.optimizerName.c_str());
Then she defines a \code{Problem} by specifying an energy function and choice of optimization method.
  % 2. Plan: defines variable sizes (and later: graph connectivity)
  % Plan *plan = Opt_ProblemPlan(optimizerState, prob,
  %                              dims, 
  %                              elemsize.data() /* strides[0] */,
  %                              stride.data() /* strides[1] */);
Third, she creates an optimization \code{Plan}, which specifies the dimensions and the layout of the image data over which the problem is to be solved.
  % 3. Solve: pass concrete input, output buffers & run an iteration (or full solve?)
  % Opt_ProblemSolve(optimizerState, plan,
  %                  isGPU ? imagesGPU.data() : imagesCPU.data(),
  %                  problemParams /* uniforms */, solverParams);
Finally, she iterates the configured solver over concrete input data until convergence.
A simple execution of the Laplacian smoothing problem over a $1920\times 1080$ image is shown in \figref{runtime_api_example}.

% subsection runtime_api (end)