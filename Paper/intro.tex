\section{Introduction}
\label{sec:intro}

% Motivation
Many graphics and vision problems are naturally expressed as least squares optimizations on an image domain.
For example, Poisson image editing, shape-from-shading, and as-rigid-as-possible warping have all been phrased as least squares optimizations, allowing them to be described tersely as simple energy functions over pixels \TODO{cites}.
In many of these applications, real-time performance is critical for interactive feedback [or streaming operation], requiring efficient parallel or GPU-based solvers.
However, making efficient parallel solvers in general is an open problem, and explicitly forming a problem as a matrix to be solved by generic linear algebra libraries is inefficient.

% State-of-the-art
Recent work has demonstrated real-time performance for nonlinear least squares graphics problems on using a variant of Gauss-Newton optimization, with a preconditioned conjugate gradient inner loop, on the GPU \TODO{cites}.
Key to the performance of these methods are two ideas: operating in-place to avoid ever forming the full matrices at the core of the solve, and blocking the computation in the image domain to exploit locality.
However, this comes at enormous implementation cost:
the terse and simple energy function has to be manually transformed into a complex product of partial derivatives and preconditioner terms ($J^TJp$ at each point in the image),
and the in-place formulation tightly intertwines this application-specific logic with the complex details of the solver.
In all, this approach delivers excellent performance, but requires thousands of lines of highly-tuned CUDA code—far removed from the simple energy function which defines a problem—to create a custom in-place solver for each application (\figref{app_summary}).

% Goal
We want to make this type of real-time optimization accessible to a much wider community of graphics and vision programmers.
To do this, we have
created a new language, \OPT, which lets a programmer easily write sum-of-squares energy functions over pixels,
and the corresponding compiler, which takes these energies, and a choice of solver method, and automatically generates highly optimized in-place solvers.
\TODO{Reference concrete Laplacian teaser example?}

% How
Our system is able to do this thanks to four key ideas.
First, we implement a generalization of the parallel Gauss-Newton method popular in recent work, abstracted to work with arbitrary least squares energies over an image.
Second, our compiler automatically generates the derivative terms required by these solvers using general-purpose automatic \JRK{symbolic?} differentiation.
Our automatic differentiation system is based on a simplified version of the D* algorithm \cite{dstar}.
Third, in generating these residual computations, our language exposes and our compiler exploits two key restrictions in the energy problems we support: unknowns and other data are arranged in a 2-dimensional pixel grid, and the dependence among points in the energy are \emph{stencil} patterns (fixed-size and shift-invariant local windows around each pixel).
Finally, we use metaprogramming and code generation to combine the skeleton of our solver methods with the application-specific terms derived from the energy function, without incurring any runtime overhead.

% Punchline
This system gives both far better performance and even easier expression than traditional general-purpose solver libraries: performance is competitive with state-of-the-art, application-specific, in-place GPU solvers, and it requires the programmer to provide only the energy to be minimized as a simple function of pixel index, not the fully-formed derivative matrices of the system to be solved.

% Scope
This power comes from exploiting constraints in the problems we address.
Specifically, \TODO{problems of the form...linalg limits?}, where unkowns and data vectors correspond to 2-dimensional images, and where energies \TODO{take the form...sum of square of ...} with energy terms expressed for each pixel in terms of real-valued expressions applied to a stencil of unknown and data values around the index of the current pixel.
These restrictions still allow the expression of many useful graphics and vision problems.
We demonstrate state-of-the-art real-time performance on five applications (\figref{app_summary}): Laplacian and bi-Laplacian image smoothing, Poisson image editing, shape-from-shading, and as-rigid-as-possible image deformation \TODO{cites}.
This performance matches or exceeds state-of-the-art hand-written GPU solvers while requiring orders of magnitude less code.
They require less code, even, than implementations in general-purpose GPU solver libraries, which they dramatically outperform.